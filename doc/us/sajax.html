<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<?xml encoding="utf8" version="1.0"?>
<HTML xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
<TITLE>sajax.html</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="http://www.keplerproject.org/doc.css" rel=stylesheet>
</HEAD>
<BODY>
<DIV id=container>
<DIV id=product>
<DIV id=product_logo><A href="http://www.keplerproject.org"><IMG 
alt="Xavante logo" src="xavante.gif"> </A></DIV>
<DIV id=product_name><BIG><STRONG>Xavante</STRONG></BIG></DIV>
<DIV id=product_description>A Lua Web Server with CGILua support</DIV></DIV>
<DIV id=main>
<DIV id=navigation></DIV>
<DIV id=content>
<H2>Sajax.lua</H2>
<H3>Background</H3>
<P>Sajax.lua is a Lua version of SAJAX (Simple AJAX toolkit) written (in PHP) by 
Thomas Lackner at <A 
href="http://www.modernmethod.com/sajax/">http://www.modernmethod.com/sajax/</A>. 
AJAX is short for "Ashynchronous JAvascript and Xml", a new name for a 
not-so-new technology. </P>
<P>In short, AJAX is about writing your user GUI in HTML, with user 
interactivity in client-side Javascript, and get server data via HTTP, usually 
in the form of XML structures. Sajax doesn't use a lot of XML itself, but the 
JavaScript object used to make the HTTP queries is XMLHttpRequest(), so the 'X' 
in the name remains. </P>
<P>Sajax makes it easy to do by letting functions (running in the server) to be 
called from JavaScript (running in the client). Just register your functions and 
Sajax will write JavaScript 'stubs' (small functions that handle the query to 
the server) with the same name as the server-side functions. </P>
<H3>Usage</H3>
<P>Example, taken from 'calculator.lp' :</P><PRE class=example>&lt;%
    require "sajax"

    function multiply(x, y)
        return x * y
    end

    sajax.init()
    sajax.export ("multiply", multiply)
    if sajax.handle_client_request () then return end
%&gt;
</PRE>
<P>This code defines a very trivial function and registers it with 
sajax.export(), after all exported functions have been registered, it calls 
sajax.handle_client_request() and finishes the script if there has been a Sajax 
request. </P><PRE class=example>&lt;head&gt;
	&lt;title&gt;Multiplier&lt;/title&gt;
	&lt;script&gt;
	&lt;%
		sajax.show_javascript();
	%&gt;
	
	function do_multiply_cb(z) {
		document.getElementById("z").value = z;
	}
	
	function do_multiply() {
		var x, y;
		
		x = document.getElementById("x").value;
		y = document.getElementById("y").value;
		x_multiply(x, y, do_multiply_cb);
	}
	&lt;/script&gt;
&lt;/head&gt;
</PRE>
<P>The &lt;head&gt; part of the page includes some JavaScript code. The call to 
sajax.show_javascript() inserts the support functions and the function stubs 
that remotely call the registered functions. </P>
<P>The function do_multiply() reads two values, 'x' and 'y' from form fields and 
calls the function stub x_multiply(), adding as the last parameter a callback 
function. x_multiply() will perform the query to the server, and return 
immediatly. The callback function do_multiply_cb() will be called with the 
server function's return value as the only parameter. In this example, 
do_multiply_cb() puts the multiplication result into a form field. </P><PRE class=example>&lt;body&gt;
	&lt;input type="text" name="x" id="x" value="2" size="3"&gt;
	*
	&lt;input type="text" name="y" id="y" value="3" size="3"&gt;
	=
	&lt;input type="text" name="z" id="z" value="" size="3"&gt;
	&lt;input type="button" name="check" value="Calculate"
		onclick="do_multiply(); return false;"&gt;
&lt;/body&gt;
</PRE>
<P>The body of the Lua Page contains the HTML fields used by the JavaScript 
functions, and also the button that calls the do_multiply() function. In AJAX, 
the HTML code is mostly the initial canvas where JavaScript code is executed, 
using both user events and server responses as inputs to operation. </P>
<H3>Notes</H3>
<UL>
  <LI>The sajax.handle_client_request() function must be called after all the 
  server-side functions has been registered, but before any other page 
  processing. If the call returns true, the script must be finished immediatly. 
  <LI>The JavaScript 'stubs' names are the names under which the server-side 
  functions were exported, with a 'x_' prepended. 
  <LI>The value returned by the server-side function is converted to a string 
  and passed as the parameter to a JavaScript callback. Only one returned value 
  is passed. 
  <LI>The JavaScript stub returns immedatly after posting the query to the 
  server; to do work after the server-side function has returned, use the 
  callback function. That's the 'Asynchronous' part in AJAX. </LI></UL>
<H3>How it works</H3>
<P>There are two different operation modes in sajax.lua: the generic CGILua 
mode, and a Xavante-specific optimization. </P>
<P>In generic CGILua, Sajax.lua works very similar to the PHP version: 
<OL>
  <LI>When the user enters the URL of the CGILua Script (or LuaPage), all the 
  functions are registered; but handle_client_request() returns false, the 
  script continues and produces the whole page, including the JavaScript stubs 
  generated by show_javascript(). 
  <LI>A user event calls up some JavaScript, which in turn may call some of the 
  stubs. 
  <LI>The JavaScript stub build a HTTP request with the same URL of the current 
  page, with parameters indicating the function it wants to call, and any other 
  parameter passed by the calling JavaScript code. Also adds the callback 
  function to the request object. The request is posted to the server, and the 
  stub returns immediatly. 
  <LI>The client query is handled in the server by the same Lua script. The same 
  functions get registered, but this time the handle_client_request() function 
  detects the request, pulls the required function name and other parameters, 
  and calls the registered function. It then builds the response with the 
  returned value, sends it to the client, and returns true to indicate the main 
  Lua Script that the request has been handled and it should terminate. 
  <LI>The response is handled by the client-side JavaScript; if the response is 
  positive, the callback function is called with the returned value, if the 
  response signals an error, an alert is posted. </LI></OL>
<P></P>
<P>If sajax.lua detects that the current webserver is Xavante, it uses a 
different workflow: 
<OL>
  <LI>When the user enters the URL of the CGILua Script (or LuaPage), all the 
  functions are registered in the Xavante dispatch table as handlers for URLs of 
  the form: 'http://www.server.com/somedir/script.lp/funcname'. 
  handle_client_request() does nothing and always returns false. 
  <LI>The JavaScript stubs call the functions with their specific URL, adding 
  the parameters passed by the calling client-side code. 
  <LI>The Xavante dispatch code calls the required function, no CGILua 
  environment is set up. 
  <LI>The returned value is handled in the same way, calling the client-side 
  callback. </LI></OL>As can be seen, the CGILua system is called only for the 
initial page request; the remote function calls don't fetch the filesystem, and 
the CGILua environment and parsing is bypassed. That means that the server-side 
functions can't use most CGILua functions, so any session identifying key should 
be passed as a function parameter. 
<P></P></DIV></DIV>
<DIV id=about>
<P><A href="http://validator.w3.org/check?uri=referer"><IMG height=31 
alt="Valid XHTML 1.0!" src="http://www.w3.org/Icons/valid-xhtml10" 
width=88></A></P>
<P><SMALL>$Id: sajax.html,v 1.1 2005/04/04 18:44:05 carregal Exp $ 
</SMALL></P></DIV></DIV></BODY></HTML>
